Skillbar_Handler:
  type: world
  debug: false
  events:
    on player scrolls their hotbar:
    - if <player.gamemode.id> == 2 && <context.new_slot> <= 6 {
      - determine passively cancelled
      - if <player.has_flag[Class]> && <player.flag[Class]> !== Citizen {
        - if <context.previous_slot> <= 6 {
          - adjust <player> item_slot:7
        }
        - if <player.inventory.slot[<context.new_slot>]> == i@air {
          - inventory set origin:i@Unassigned_Skill slot:<context.new_slot>
          - queue clear
        }
        - foreach <player.inventory.slot[<context.new_slot>].lore> {
          - if <def[value]> contains Default Skill || <def[value]> contains Unassigned Skill || <def[value]> contains Optional Skill {
            - define Check true
          }
        }
        - if <player.inventory.slot[<context.new_slot>].scriptname> == Unassigned_Skill {
          - narrate "<&a><&l>[Skill] <&7>This skill has not been assigned yet!"
        }
        else if <def[Check]> == true {
          - define Skill <player.inventory.slot[<context.new_slot>].scriptname.to_titlecase>
          - define Skill_Slot <context.new_slot>
          - inject Cast_Sequence
        }
      }
    }
    on player clicks in inventory:
    - if <player.gamemode.id> == 2 && <context.slot> <= 6 {
      - foreach <context.item.lore> {
        - if <def[value]> contains Default Skill || <def[value]> contains Unassigned Skill || <def[value]> contains Optional Skill {
          - determine passively cancelled
        }
      }
    }

Cast_Sequence:
  type: task
  debug: false
  speed: 0
  script:
    - if <player.has_flag[Silence_Effect]> {
      - narrate "<&a><&l>[Skill] <&7>You are currently silenced for another <&f><player.flag[Silence_Effect].expiration.in_seconds.round_to[1]>s<&7>!"
      - queue clear
    }
    - if <player.has_flag[Stun_Effect]> {
      - narrate "<&a><&l>[Skill] <&7>You are currently Stunned for another <&f><player.flag[Stun_Effect].expiration.in_seconds.round_to[1]>s<&7>!"
      - queue clear
    }
    - define Class_Skill_Config s@<player.flag[Class]>_Skill_Config
    - define Class_Stat_Config s@<player.flag[Class]>_Stat_Config
    - define Skill_Cooldown <def[Skill]>_Cooldown
    - define Skill_Cost <def[Class_Skill_Config].yaml_key[<def[Skill]>_Cost].as_int||0>
    - if <player.has_flag[<def[Skill_Cooldown]>]> {
      - narrate "<&a><&l>[Skill] <&f><def[Skill]> <&7>has <&f><player.flag[<def[Skill_Cooldown]>].expiration.in_seconds.round_to[1]>s <&7>until it's ready!"
      - queue clear
    }
    - if <yaml[<player.uuid>].read[General.Mana].as_int> >= <def[Skill_Cost]> {
      - define Mana <yaml[<player.uuid>].read[General.Mana].as_int>
      - yaml id:<player.uuid> set General.Mana:<def[Mana].sub[<def[Skill_Cost]>]>
      - define Mana <def[Mana].sub[<def[Skill_Cost]>]>
      - adjust <player> fake_experience:<def[Mana].div[20]>|<def[Mana]>
    }
    else {
      - narrate "<&a><&l>[Skill] <&7>You do not have enough <&f><def[Class_Stat_Config].yaml_key[Class_Resource]||Mana> <&7>to use this ability!"
      - queue clear
    }
    - inject <def[Skill]>_Cast
    - flag player <def[Skill_Cooldown]> duration:<def[Class_Skill_Config].yaml_key[<def[Skill_Cooldown]>].as_int||10>
    - define Message "<def[Class_Skill_Config].yaml_key[<def[Skill]>_Message]||<&a><&l>[Skill] <&f><player.name> <&7>has used <&f><def[Skill]><&7>!>"
    - narrate "<parse:<def[Message]>>" targets:<player.location.find.players.within[25]>
    - repeat <def[Class_Skill_Config].yaml_key[<def[Skill_Cooldown]>].as_int.mul[1.5]||15> {
      - adjust <player.inventory.slot[<def[Skill_Slot]>]> quantity:<player.flag[<def[Skill_Cooldown]>].expiration.in_seconds.round> save:Cooldown
      - take slot:<def[Skill_Slot]>
      - inventory set origin:<entry[Cooldown].result> slot:<def[Skill_Slot]>
      - wait 0.75s
    }

Unassigned_Skill:
  type: item
  debug: false
  material: pumpkin_seeds
  display name: <&7>Unassigned
  lore:
  - <&f>Unassigned Skill